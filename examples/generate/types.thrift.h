/*
 * Copyright (c) 2020-2023 curoky(cccuroky@gmail.com).
 *
 * This file is part of go-thrift-parser.
 * See https://github.com/curoky/blink for further info.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code generated by Compiler (0.1.0).
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING.
// @filename: types.thrift.h
// @source: types.thrift
// @date:
// @version: 0.1.0
#pragma once
#include <vector>
#include <map>
#include <set>
#include <string>
#define RTTR_API()
#define RTTR_ENABLE()
namespace foo {
  static const std::string  GLOBAL_CONST_VAR_STRING_ = "123";
  inline static const std::string& GLOBAL_CONST_VAR_STRING() {
    return GLOBAL_CONST_VAR_STRING_;
  }
enum struct EnumType {
    ZERO = 0,
    ONE = 1,
    TWO = 2,
    THREE = 3,
};
struct OutterStructType;
struct StructType;
typedef std::string StrType;
class RTTR_API StructType {
 public:
  StructType();
  StructType(StructType&&) = default;
  StructType(const StructType&) = default;
  StructType& operator=(StructType&&) = default;
  StructType& operator=(const StructType&) = default;
  bool var_bool ;
  char var_byte ;
  int16_t var_i16 ;
  int32_t var_i32 ;
  int64_t var_i64 ;
  double var_double ;
  std::string var_string ;
  std::string var_binary ;
  StrType var_string_type ;
  std::vector<std::string> var_string_list ;
  std::vector<std::string> var_binary_list ;
  std::set<std::string> var_string_set ;
  std::map<std::string,std::string> var_string_binary_map ;
  EnumType var_enum ;
  std::set<EnumType> var_enum_set ;
  UnionType var_union ;
  int32_t var_required_i32 ;
  int32_t var_optional_i32 ;
  struct {
        bool var_required_i32 = false;
  } __isset = {};
    template <typename T = bool>
    auto& set_var_bool(T&& x) {
      this->var_bool = std::forward<T>(x);
        __isset.var_bool = true;
      return this->var_bool;
    }
    const bool* get_var_bool() const {
      return __isset.var_bool == true ? &this->var_bool : nullptr;
    }
    template <typename T = char>
    auto& set_var_byte(T&& x) {
      this->var_byte = std::forward<T>(x);
        __isset.var_byte = true;
      return this->var_byte;
    }
    const char* get_var_byte() const {
      return __isset.var_byte == true ? &this->var_byte : nullptr;
    }
    template <typename T = int16_t>
    auto& set_var_i16(T&& x) {
      this->var_i16 = std::forward<T>(x);
        __isset.var_i16 = true;
      return this->var_i16;
    }
    const int16_t* get_var_i16() const {
      return __isset.var_i16 == true ? &this->var_i16 : nullptr;
    }
    template <typename T = int32_t>
    auto& set_var_i32(T&& x) {
      this->var_i32 = std::forward<T>(x);
        __isset.var_i32 = true;
      return this->var_i32;
    }
    const int32_t* get_var_i32() const {
      return __isset.var_i32 == true ? &this->var_i32 : nullptr;
    }
    template <typename T = int64_t>
    auto& set_var_i64(T&& x) {
      this->var_i64 = std::forward<T>(x);
        __isset.var_i64 = true;
      return this->var_i64;
    }
    const int64_t* get_var_i64() const {
      return __isset.var_i64 == true ? &this->var_i64 : nullptr;
    }
    template <typename T = double>
    auto& set_var_double(T&& x) {
      this->var_double = std::forward<T>(x);
        __isset.var_double = true;
      return this->var_double;
    }
    const double* get_var_double() const {
      return __isset.var_double == true ? &this->var_double : nullptr;
    }
    template <typename T = std::string>
    auto& set_var_string(T&& x) {
      this->var_string = std::forward<T>(x);
        __isset.var_string = true;
      return this->var_string;
    }
    const std::string* get_var_string() const {
      return __isset.var_string == true ? &this->var_string : nullptr;
    }
    template <typename T = std::string>
    auto& set_var_binary(T&& x) {
      this->var_binary = std::forward<T>(x);
        __isset.var_binary = true;
      return this->var_binary;
    }
    const std::string* get_var_binary() const {
      return __isset.var_binary == true ? &this->var_binary : nullptr;
    }
    template <typename T = StrType>
    auto& set_var_string_type(T&& x) {
      this->var_string_type = std::forward<T>(x);
        __isset.var_string_type = true;
      return this->var_string_type;
    }
    const StrType* get_var_string_type() const {
      return __isset.var_string_type == true ? &this->var_string_type : nullptr;
    }
    template <typename T = std::vector<std::string>>
    auto& set_var_string_list(T&& x) {
      this->var_string_list = std::forward<T>(x);
        __isset.var_string_list = true;
      return this->var_string_list;
    }
    const std::vector<std::string>* get_var_string_list() const {
      return __isset.var_string_list == true ? &this->var_string_list : nullptr;
    }
    template <typename T = std::vector<std::string>>
    auto& set_var_binary_list(T&& x) {
      this->var_binary_list = std::forward<T>(x);
        __isset.var_binary_list = true;
      return this->var_binary_list;
    }
    const std::vector<std::string>* get_var_binary_list() const {
      return __isset.var_binary_list == true ? &this->var_binary_list : nullptr;
    }
    template <typename T = std::set<std::string>>
    auto& set_var_string_set(T&& x) {
      this->var_string_set = std::forward<T>(x);
        __isset.var_string_set = true;
      return this->var_string_set;
    }
    const std::set<std::string>* get_var_string_set() const {
      return __isset.var_string_set == true ? &this->var_string_set : nullptr;
    }
    template <typename T = std::map<std::string,std::string>>
    auto& set_var_string_binary_map(T&& x) {
      this->var_string_binary_map = std::forward<T>(x);
        __isset.var_string_binary_map = true;
      return this->var_string_binary_map;
    }
    const std::map<std::string,std::string>* get_var_string_binary_map() const {
      return __isset.var_string_binary_map == true ? &this->var_string_binary_map : nullptr;
    }
    template <typename T = EnumType>
    auto& set_var_enum(T&& x) {
      this->var_enum = std::forward<T>(x);
        __isset.var_enum = true;
      return this->var_enum;
    }
    const EnumType* get_var_enum() const {
      return __isset.var_enum == true ? &this->var_enum : nullptr;
    }
    template <typename T = std::set<EnumType>>
    auto& set_var_enum_set(T&& x) {
      this->var_enum_set = std::forward<T>(x);
        __isset.var_enum_set = true;
      return this->var_enum_set;
    }
    const std::set<EnumType>* get_var_enum_set() const {
      return __isset.var_enum_set == true ? &this->var_enum_set : nullptr;
    }
    template <typename T = UnionType>
    auto& set_var_union(T&& x) {
      this->var_union = std::forward<T>(x);
        __isset.var_union = true;
      return this->var_union;
    }
    const UnionType* get_var_union() const {
      return __isset.var_union == true ? &this->var_union : nullptr;
    }
    template <typename T = int32_t>
    auto& set_var_required_i32(T&& x) {
      this->var_required_i32 = std::forward<T>(x);
      return this->var_required_i32;
    }
    const int32_t* get_var_required_i32() const {
      return __isset.var_required_i32 == true ? &this->var_required_i32 : nullptr;
    }
    template <typename T = int32_t>
    auto& set_var_optional_i32(T&& x) {
      this->var_optional_i32 = std::forward<T>(x);
        __isset.var_optional_i32 = true;
      return this->var_optional_i32;
    }
    const int32_t* get_var_optional_i32() const {
      return __isset.var_optional_i32 == true ? &this->var_optional_i32 : nullptr;
    }
  RTTR_ENABLE()
};
class RTTR_API OutterStructType {
 public:
  OutterStructType();
  OutterStructType(OutterStructType&&) = default;
  OutterStructType(const OutterStructType&) = default;
  OutterStructType& operator=(OutterStructType&&) = default;
  OutterStructType& operator=(const OutterStructType&) = default;
  StructType req ;
  struct {
  } __isset = {};
    template <typename T = StructType>
    auto& set_req(T&& x) {
      this->req = std::forward<T>(x);
        __isset.req = true;
      return this->req;
    }
    const StructType* get_req() const {
      return __isset.req == true ? &this->req : nullptr;
    }
  RTTR_ENABLE()
};
} // namespace foo
